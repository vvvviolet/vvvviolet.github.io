<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on 莫惊风</title>
        <link>https://vvvviolet.github.io/post/</link>
        <description>Recent content in Posts on 莫惊风</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <lastBuildDate>Wed, 04 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://vvvviolet.github.io/post/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>依赖注入</title>
        <link>https://vvvviolet.github.io/p/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link>
        <pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate>
        
        <guid>https://vvvviolet.github.io/p/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</guid>
        <description>&lt;p&gt;Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。
采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。而具体获取的方法、对象被获取时的状态由配置文件（如XML）来指定。&lt;/p&gt;
&lt;p&gt;就是程序里不用再new了，托管出去，让第三方来new。&lt;/p&gt;
&lt;p&gt;IoC模式，系统中通过引入实现了IoC模式的IoC容器，即可由&lt;strong&gt;IoC容器来管理对象的生命周期、依赖关系等&lt;/strong&gt;，从而使得应用程序的配置和依赖性规范与实际的应用程序代码分离。其中一个特点就是通过文本的配置文件进行应用程序组件间相互关系的配置，而不用重新修改并编译具体的代码。&lt;/p&gt;
&lt;p&gt;当前比较知名的IoC容器有：Pico Container、Avalon 、Spring、JBoss、HiveMind、EJB等。
在上面的几个IoC容器中，轻量级的有Pico Container、Avalon、Spring、HiveMind等，超重量级的有EJB，而半轻半重的有容器有JBoss，Jdon等。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【从0开始的写操作系统】 mit6.828 lab1|GDT,LDT,BIOS</title>
        <link>https://vvvviolet.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mit6.828-lab1gdtldtbios/</link>
        <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
        
        <guid>https://vvvviolet.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mit6.828-lab1gdtldtbios/</guid>
        <description>&lt;img src="https://vvvviolet.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mit6.828-lab1gdtldtbios/dasheng.jpg" alt="Featured image of post 【从0开始的写操作系统】 mit6.828 lab1|GDT,LDT,BIOS" /&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gdb手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;bios&#34;&gt;BIOS&lt;/h1&gt;
&lt;p&gt;BIOS 的作用就是自检，然后从 MBR 中读取出启动引导程序。那么，启动引导程序最主要的作用就是加载操作系统的内核。当然，每种操作系统的启动引导程序都是不同的。&lt;/p&gt;
&lt;p&gt;简单地理解 BIOS，它就是固化在主板上一个 ROM（只读存储器）芯片上的程序，主要保存计算机的基本输入/输出信息、系统设置信息、开机自检程和系统自启动程序，用来为计算机提供&lt;strong&gt;最底层&lt;/strong&gt;和&lt;strong&gt;最直接&lt;/strong&gt;的硬件设置与控制&lt;/p&gt;
&lt;p&gt;也就是说，BIOS 是硬件与软件之间的接口，而且是非常基本的接口，BIOS 提供了一组基本的操作系统使用的指令，系统启动的成功与否，依赖于 BIOS。&lt;/p&gt;
&lt;p&gt;BIOS 的初始化主要完成以下 3 项工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次检查计算机硬件和外围设备（第二次自检由内核完后，后续会讲），例如 CPU、内存、风扇灯。当 BIOS 一启动，就会做一个自我检测的工作，整个自检过程也被称为 POST（Power On Self Test）自检。&lt;/li&gt;
&lt;li&gt;如果自检没有问题，BIOS 开始对硬件进行初始化，并规定当前可启动设备的先后顺序，选择由那个设备来开机。&lt;/li&gt;
&lt;li&gt;选择好开启设备后，就会从该设备的 MBR（主引导目录）中读取 Boot Loader（启动引导程序）并执行。启动引导程序用于引导操作系统启动，Linux 系统中默认使用的启动引导程序是 GRUB。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当 MBR 被加载到 RAM 之后，BIOS 就会将控制权交给 MBR，进入系统引导的第二阶段。&lt;/p&gt;
&lt;h1 id=&#34;mbr-主引导记录&#34;&gt;MBR 主引导记录&lt;/h1&gt;
&lt;p&gt;MBR 共占用了一个扇区，也就是 512 Byte。其中 446 Byte 安装了启动引导程序，其后 64 Byte 描述分区表，最后的 2 Byte 是结束标记&lt;/p&gt;
&lt;h1 id=&#34;gdtldt&#34;&gt;GDT，LDT&lt;/h1&gt;
&lt;p&gt;Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。&lt;/p&gt;
&lt;p&gt;GDT全局 LDT局部&lt;/p&gt;
&lt;h1 id=&#34;段选择子selector&#34;&gt;段选择子Selector&lt;/h1&gt;
&lt;p&gt;三部分：描述符索引（index）、TI（指示从GDT还是LDT中找）、请求特权级（RPL）&lt;/p&gt;
&lt;h1 id=&#34;mit6828-lab1&#34;&gt;mit6.828 lab1&lt;/h1&gt;
&lt;p&gt;PC 的软盘和硬盘被划分为 512 字节的区域，称为扇区。扇区是磁盘的最小传输粒度：每次读取或写入操作的大小必须是一个或多个扇区，并且在扇区边界上对齐&lt;/p&gt;
&lt;h2 id=&#34;boot-loader-的两个主要功能&#34;&gt;boot loader 的两个主要功能&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将处理器从实模式转换为32位保护模式&lt;/li&gt;
&lt;li&gt;引导加载程序通过 x86 的特殊 I/O 指令直接访问 IDE 磁盘设备寄存器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;编写设备驱动程序实际上是 OS 开发的一个非常重要的部分，但从概念或体系结构的角度来看，它也是最不有趣的部分之一，暂时略过。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ELF 二进制文件以一个固定长度的ELF 标头开始，然后是一个可变长度的程序标头 ，其中列出了要加载的每个程序部分。这些 ELF 标头的 C 定义位于inc/elf.h 中。我们感兴趣的程序部分是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.text：程序的可执行指令。&lt;/li&gt;
&lt;li&gt;.rodata：只读数据，例如由 C 编译器生成的 ASCII 字符串常量。（不过，我们不会费心设置硬件来禁止写入。）&lt;/li&gt;
&lt;li&gt;.data：数据部分保存程序的初始化数据，例如使用int x = 5 等初始化器声明的全局变量；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当链接器计算程序的内存布局时，它会为&lt;strong&gt;未初始化&lt;/strong&gt;的全局变量保留空间，例如int x，在内存中紧跟.data的名为.bss的部分中&lt;/p&gt;
&lt;p&gt;C要求“未初始化的”全局变量以零值开头。因此，无需在ELF二进制文件中存储.bss的内容；相反，链接器只记录.bss部分的&lt;strong&gt;地址和大小&lt;/strong&gt;。加载程序或程序本身必须将.bss部分归零。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;objdump -h obj/kern/kernel
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;-h, &amp;ndash;[section-]headers  Display the contents of the section headers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VMA 链接地址，节期望执行的内存地址&lt;/li&gt;
&lt;li&gt;LMA 加载地址，一个节的加载地址是该节应该被加载到内存中的内存地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，链接地址和加载地址是相同的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vaddr 虚拟地址&lt;/li&gt;
&lt;li&gt;paddr 物理地址&lt;/li&gt;
&lt;li&gt;memsz filesz 加载区域大小&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
</description>
        </item>
        <item>
        <title>天地人之道</title>
        <link>https://vvvviolet.github.io/p/</link>
        <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
        
        <guid>https://vvvviolet.github.io/p/</guid>
        <description>&lt;img src="https://vvvviolet.github.io/p/jcx.jpg" alt="Featured image of post 天地人之道" /&gt;&lt;h2 id=&#34;天地人丛书&#34;&gt;《天地人丛书》&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;凡气，清则通，昏则壅，天有光风霁月、曀阴霾雾之异，人有高明广大、庸沓鄙陋之殊，其理一也。清极则神。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;天道不穷，寒暑也；众动不穷，屈伸也。寒已而暑，暑已而寒，循环而如相反，四时之行，生杀之用，尽此矣：盖二气之嘘吸也。屈者屈其所伸，伸者伸其所屈，群动之变，不能离此二用，动静、语默、喜怒、行藏之变，尽此矣：盖二气之舒敛也。鬼神之实，不越二端而已矣。一嘘一吸，一舒一敛，升降离合于太虚之中，乃阴阳必有之几。则鬼神者，天之所显而即人之藏也。静以成形，鬼之属也，而可以迎神而来；动而成用，神之属也，而将成乎鬼以往。屈伸因乎时，而尽性以存神，则天命立于在我，与鬼神合其吉凶矣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
</description>
        </item>
        
    </channel>
</rss>

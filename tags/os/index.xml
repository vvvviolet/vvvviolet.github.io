<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>OS on 莫惊风</title>
        <link>https://vvvviolet.github.io/tags/os/</link>
        <description>Recent content in OS on 莫惊风</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <lastBuildDate>Sun, 01 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://vvvviolet.github.io/tags/os/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>【从0开始的写操作系统】 mit6.828 lab1|GDT,LDT,BIOS</title>
        <link>https://vvvviolet.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mit6.828-lab1gdtldtbios/</link>
        <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
        
        <guid>https://vvvviolet.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mit6.828-lab1gdtldtbios/</guid>
        <description>&lt;img src="https://vvvviolet.github.io/p/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-mit6.828-lab1gdtldtbios/dasheng.jpg" alt="Featured image of post 【从0开始的写操作系统】 mit6.828 lab1|GDT,LDT,BIOS" /&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gdb手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;bios&#34;&gt;BIOS&lt;/h1&gt;
&lt;p&gt;BIOS 的作用就是自检，然后从 MBR 中读取出启动引导程序。那么，启动引导程序最主要的作用就是加载操作系统的内核。当然，每种操作系统的启动引导程序都是不同的。&lt;/p&gt;
&lt;p&gt;简单地理解 BIOS，它就是固化在主板上一个 ROM（只读存储器）芯片上的程序，主要保存计算机的基本输入/输出信息、系统设置信息、开机自检程和系统自启动程序，用来为计算机提供&lt;strong&gt;最底层&lt;/strong&gt;和&lt;strong&gt;最直接&lt;/strong&gt;的硬件设置与控制&lt;/p&gt;
&lt;p&gt;也就是说，BIOS 是硬件与软件之间的接口，而且是非常基本的接口，BIOS 提供了一组基本的操作系统使用的指令，系统启动的成功与否，依赖于 BIOS。&lt;/p&gt;
&lt;p&gt;BIOS 的初始化主要完成以下 3 项工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次检查计算机硬件和外围设备（第二次自检由内核完后，后续会讲），例如 CPU、内存、风扇灯。当 BIOS 一启动，就会做一个自我检测的工作，整个自检过程也被称为 POST（Power On Self Test）自检。&lt;/li&gt;
&lt;li&gt;如果自检没有问题，BIOS 开始对硬件进行初始化，并规定当前可启动设备的先后顺序，选择由那个设备来开机。&lt;/li&gt;
&lt;li&gt;选择好开启设备后，就会从该设备的 MBR（主引导目录）中读取 Boot Loader（启动引导程序）并执行。启动引导程序用于引导操作系统启动，Linux 系统中默认使用的启动引导程序是 GRUB。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当 MBR 被加载到 RAM 之后，BIOS 就会将控制权交给 MBR，进入系统引导的第二阶段。&lt;/p&gt;
&lt;h1 id=&#34;mbr-主引导记录&#34;&gt;MBR 主引导记录&lt;/h1&gt;
&lt;p&gt;MBR 共占用了一个扇区，也就是 512 Byte。其中 446 Byte 安装了启动引导程序，其后 64 Byte 描述分区表，最后的 2 Byte 是结束标记&lt;/p&gt;
&lt;h1 id=&#34;gdtldt&#34;&gt;GDT，LDT&lt;/h1&gt;
&lt;p&gt;Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。&lt;/p&gt;
&lt;p&gt;GDT全局 LDT局部&lt;/p&gt;
&lt;h1 id=&#34;段选择子selector&#34;&gt;段选择子Selector&lt;/h1&gt;
&lt;p&gt;三部分：描述符索引（index）、TI（指示从GDT还是LDT中找）、请求特权级（RPL）&lt;/p&gt;
&lt;h1 id=&#34;mit6828-lab1&#34;&gt;mit6.828 lab1&lt;/h1&gt;
&lt;p&gt;PC 的软盘和硬盘被划分为 512 字节的区域，称为扇区。扇区是磁盘的最小传输粒度：每次读取或写入操作的大小必须是一个或多个扇区，并且在扇区边界上对齐&lt;/p&gt;
&lt;h2 id=&#34;boot-loader-的两个主要功能&#34;&gt;boot loader 的两个主要功能&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将处理器从实模式转换为32位保护模式&lt;/li&gt;
&lt;li&gt;引导加载程序通过 x86 的特殊 I/O 指令直接访问 IDE 磁盘设备寄存器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;编写设备驱动程序实际上是 OS 开发的一个非常重要的部分，但从概念或体系结构的角度来看，它也是最不有趣的部分之一，暂时略过。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ELF 二进制文件以一个固定长度的ELF 标头开始，然后是一个可变长度的程序标头 ，其中列出了要加载的每个程序部分。这些 ELF 标头的 C 定义位于inc/elf.h 中。我们感兴趣的程序部分是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.text：程序的可执行指令。&lt;/li&gt;
&lt;li&gt;.rodata：只读数据，例如由 C 编译器生成的 ASCII 字符串常量。（不过，我们不会费心设置硬件来禁止写入。）&lt;/li&gt;
&lt;li&gt;.data：数据部分保存程序的初始化数据，例如使用int x = 5 等初始化器声明的全局变量；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当链接器计算程序的内存布局时，它会为&lt;strong&gt;未初始化&lt;/strong&gt;的全局变量保留空间，例如int x，在内存中紧跟.data的名为.bss的部分中&lt;/p&gt;
&lt;p&gt;C要求“未初始化的”全局变量以零值开头。因此，无需在ELF二进制文件中存储.bss的内容；相反，链接器只记录.bss部分的&lt;strong&gt;地址和大小&lt;/strong&gt;。加载程序或程序本身必须将.bss部分归零。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;objdump -h obj/kern/kernel
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;-h, &amp;ndash;[section-]headers  Display the contents of the section headers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VMA 链接地址，节期望执行的内存地址&lt;/li&gt;
&lt;li&gt;LMA 加载地址，一个节的加载地址是该节应该被加载到内存中的内存地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，链接地址和加载地址是相同的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vaddr 虚拟地址&lt;/li&gt;
&lt;li&gt;paddr 物理地址&lt;/li&gt;
&lt;li&gt;memsz filesz 加载区域大小&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
</description>
        </item>
        
    </channel>
</rss>
